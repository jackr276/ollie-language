Syntax of ollie-lang in BNF Form
Everything surrounded in angle brackets(<>) is a nonterminal

1. <program>            ::= {<decl_part>}*

2. <decl_part>          ::= <func_def>
                          | <decl>

3. <func_dec>           ::= <storage_spec>? func <func_ident> <param_list> -> <type_spec> <compound_statement>

4. <storage_spec>       ::= static
	 			          | external
						  | user_type

5.  <type_spec> 		 ::= {<pointer>}* <type>

6.  <pointer> 			 ::= ref

7.  <type>               ::= void | u_int8 | s_int8 | u_int16 | s_int16 | u_int32 | s_int32 | u_int64 | s_int64
							 | float32 | float64 | char | str | <enumeration_spec> | <structure_spec> | <user_defined_type>

8.  <jump_statement>     ::= jump <ident>
						  | continue;
						  | break;
						  | ret {<expression>}?
							
9.  <compound_statement>  ::= {{<declaration>}* {<statement>}*}

10. <iterative_statement> ::= while( <expression> ) do <statement>
							| do <statement> while( <expression> )
							| for( {<expression>}? ; {<expression>}? ; {<expression>}? ) do <statement>

11. <if_statement> 		  ::= if( <expression> ) then <statement> {else <statement>}*
12. <switch_statement> 	  ::= switch on( <expression> ) <statement>
13. <logical_or_expr> 	  ::= <logical_and_expr> | <logical-or-expression> or <logical-and-expression>
14. <logical_and_expr> 	  ::= <inclusive_or_expr> | <logical-and-expression> and <inclusive_or_expression>
15. <inclusive_or_expr>   ::= <exclusive_or_expr> | <inclusive-or-expr> | <exclusive_or_expr>
16. <exclusive_or_expr>   ::= <and-expr> | <exclusive_or_expr> ^ <and_expr>
17. <and-expr> 			  ::= <equality_expr> | <and_expr> & <equality_expr>
18. <equality_expr> 	  ::= <relational_expr> | <equality_expr> == <relational_expr> | <equality_expr> != <relational_expr>
19. <relational_expr> 	  ::= <shift_expr> | <relational_expr> < <shift_expr> | <relational_expr> > <shift_expr> 
							| <relational_expr> >= <shift_expr> | <relational_expr> <= <shift_expr>

20. <shift_expr> 		  ::= <additive_expr> | <shift_expr> << <additive_expr> | <shift_expr> >> <additive_expr>
21. <additive_expr> 	  ::= <mult_expr> | <additive_expr> + <mult_expr> | <additive_expr> - <mult_expr>
22. <mult_expr> 		  ::= <cast_expr> | <mult_expr> * <cast_expr> | <mult_expr> * <cast_expr>
23. <cast_expr> 		  ::= <unary_expr> | ( <type_name> ) <unary_expr>
24. <unary_expr> 		  ::= <postfix_expr> | preinc <unary_expr> | predec <unary_expr> | <unary_op> <cast_expr>
25. <unary_opt> 		  ::= memaddr | deref | + | - | ~ | ! 


13. <func_ident> 		::= <letter>{(<letter> | <digit> | _ | $)}*
14. <ident>				::= (<letter> | <digit> | _ | $){(<letter> | <digit> | _ | $)}*

15. <int_const> 			::= {-}?[1-9][0-9]*
16. <float_const>  		    ::= {-}?[0-9]+.[1-9]*
17. <str_const>			    ::= "<ASCII CHARACTER 33-127>"
18. <bool_const>			::= (True | False)
19. <digit> 				::= [0-9]
20. <letter>				::= [a-zA-Z]




