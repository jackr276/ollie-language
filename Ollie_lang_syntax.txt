The final form of the Ollie language syntax, as implemented by this compiler.

Rules are in no particular order. Nonterminals are enclosed inside of <>

Epsilon means that no production is required for the rule. Essentially, it is a blank rule

######################## Ollie language top level statements ##############################

<program> ::= {<declaration-partition>}+

<declaration-partition> ::= <function-defintion>
						  | <declaration>

<declaration> ::= <declare-statement>
				| <let-statement>
				| <define-statement>
				| <alias-statement>

################### Ollie language definition/declaration statements ########################

<function-definition> ::= func {:<function-specifier>}? <identifer> ({<parameter-list>}?) ->  <type-specifier> <compound-statement>

<function-specifier> ::= static
					   | external

<compound-statement> ::= { {<declaration>}* {<statement>}* }

<parameter-list> ::= <parameter-declaration><parameter-list-prime>
					| epsilon

<parameter-list-prime> ::= , <parameter-declaration><parameter-list-prime>
						 | epsilon

<parameter-declaration> ::= {constant}? <type-specifier> <identifier>

<declare-statement> ::= declare {constant}? {<storage-class-specifier>}? <type-specifier> <declarator>;

<let-statement> ::= let {constant}? {<storage-class-specifier>}? <type-specifier> <declarator> := <initializer>;

<storage-class-specifier> ::= static
							| external
							| register

<define-statement ::= define <complex-type-definer> {as <alias-identifer>}?;

<complex-type-definer> ::= <enumerated-definer>
						 | <construct-definer>

<enumerated-definer> ::= define enumerated <identifier> { <enumerator><enumerator-list-prime> } as <identifier>;

<construct-definer> ::= define construct <identifier> { <construct-member-list> }

<construct-member-list> ::= <construct-member><construct-member-list-prime>

<construct-member-list-prime> ::= , <construct-member><construct-member-list-prime>

<construct-member> ::= {constant}? <type-specifier> <identifier>

<enumerator-list-prime> ::= , <enumerator><enumerator-list-prime>
						  | epsilon

<enumerator> ::= <identifier>

<alias-statement> ::= alias <type-specifier> as <alias-identifier>;

<alias-identifer> ::= <identifier>

<declarator> ::= <identifer>
				 <identifer>{<array-accessor>}?
				 <identifier>{<construct-accessor}?

<array-accessor> ::= [ {constant-expression}? ]<array-accessor-prime>

<array-accessor-prime> ::= [ {constant-expression}? ]<array-accessor-prime>
						 | epsilon

<construct-accessor> ::= => <ident><construct-accessor-prime>
					   | : <ident><construct-accessor-prime>

<construct-accessor-prime> ::= => <ident><construct-accessor-prime>
						 	 | : <ident><construct-accessor-prime>
							 | epsilon

<statement> ::= <labeled-statement>
			  | <expression-statement>
			  | <compound-statement>
			  | <if-statement>
			  | <switch-statement>
			  | <iterative-statement>
			  | <branch-statement>

<iterative-statement> ::= <while-statement>
						| <do-while-statement>
						| <for-statement>

<while-statement> ::= while( <expression> ) do <compound-statement> 

<do-while-statement> ::= do <compound-statement> while( <expression> );

<for-statement> ::= for( {<expression>}? ; {<expression>}? ; {<expression>}? ) do <compound-statement>
 
<switch-statement> ::= switch on( <expression> ) {<labeled-statement>*}

<branch-statement> ::= <jump-statement>
					 | <continue-statement>
					 | <break-statement>
					 | <return-statement>

<jump-statement> ::= jump <label-identifier>;

<continue-statement> ::=  continue when({<conditional-expression>}?); 

<break-statement> ::= break {when(<conditional-expression>)}?; 

<return-statement> ::= ret {<conditional-expression>}?;

<if-statement> ::= if( <expression> ) then <compound-statement> {else <if-statement | compound-statement>}*

<labeled-statement> ::= @<label-identifier> <compound-statement>
					  | case <constant-expression> <compound-statement>
 					  | default <compound-statement>

<expression-statement> ::= {<expression>}?;

########################## Ollie language expression rules ##################################

<constant-expression> ::= <conditional-expression> 

<conditional-expression> ::= <logical-or-expression>

<logical-or-expression> ::= <logical-and-expression><logical-or-expression-prime>

<logical-or-expression-prime ::= ||<logical-and-expression><logical-or-expression-prime>

<logical-and-expression> ::= <inclusive-or-expression><logical-and-expression-prime>

<logical-and-expression-prime> ::= &&<inclusive-or-expression><logical-and-expression-prime>

<inclusive-or-expression> ::= <exclusive-or-expression><inclusive-or-expression-prime>

<inclusive-or-expression-prime> ::= |<exclusive-or-expression><inclusive-or-expression-prime>

<exclusive-or-expression> ::= <and-expression> 
							| <and_expression><exclusive-or-expression-prime>

<exclusive-or-expression-prime> ::= ^<and_expression><exlcusive-or-expression-prime>

<and-expression> ::= <equality-expression> 
				   | <equality-expression><and-expression-prime>

<and-expression-prime> ::= <equality-expression><and-expression-prime>

<equality-expression> ::= <relational-expression> 
						| <relational-expression> == <relational-expression>
						| <relational-expression> != <relational-expression>

<relational-expression> ::= <shift-expression>
					 	  | <shift-expression> > <shift-expression>
					  	  | <shift-expression> < <shift-expression>
						  | <shift-expression> >= <shift-expression>
						  | <shift-expression> <= <shift-expression>

<shift-expression> ::= <additive-expression> 
				   	|  <additive-expression> << <additive-expression> 
					|  <additive-expression> >> <additive-expression>

<additive-expression> ::= <multiplicative-expression> 
					  	| <multiplicative-expression><additive-expression-prime>
	
<additive-expression-prime> ::= + <multiplicative-expression><additive-expression-prime>
							  | - <multiplicative-expression><additive-expression-prime>

<multiplicative-expression> ::= <cast-expression>
							  | <cast-expression><multiplicative-expression-prime>

<multiplicative-expression-prime> ::= *<cast-expression><multiplicative-expression-prime>
									| /<cast-expression><multiplicative-expression-prime>
									| %<cast-expression><multiplicative-expression-prime>

<cast-expression> ::= <unary-expression> 
					| < <type-name> > <unary-expression>

<unary-expression> ::= <postfix-expression>
					 | ++<unary-expression> 
					 | --<unary-expression> 
					 | <unary-operator> <cast-expression>
					 | typesize(<type-specifier>)

<unary-operator> ::= & 
				   | * 
				   | + 
				   | - 
				   | ~ 
				   | ! 

<postfix-expression> ::= <primary-expression>
					   | <primary-expression> {{<construct-accessor>}*{<array-accessor>*}}* {++|--}?
					   | <function-call>

<function-call> ::= !<identifier>({conditional-expression}*)
					   
<primary-expression> ::= <identifier>
                       | <constant>
                       | ( <expression> )

<expression> ::= <assignment-expression>
			   | <assignment-expression><expression_prime>

<expression_prime> ::= , <assignment-expression><expression_prime>

<assignment-expression> ::= <conditional-expression>
						  | asn <unary-expression> := <conditional_expression>


########################## Ollie language type system #######################################

<type-specifier> ::= <type-name>{<type-address-specifier>}*

{type-address-specifier} ::= [<constant>]
						    | &

<type-name> ::= void
			  | u_int8
			  | s_int8
			  | u_int16
			  | s_int16
			  | u_int32
			  | s_int32
			  | u_int64
			  | s_int64
			  | float32
			  | float64
			  | char
			  | <enumerated-type>
			  | <construct-type>
			  | <aliased-type>

<enumerated-type> ::= enumerated <identifer>

<construct-type> ::= construct <identifier>

<aliased-type> ::= <identifier>

#############################################################################################
